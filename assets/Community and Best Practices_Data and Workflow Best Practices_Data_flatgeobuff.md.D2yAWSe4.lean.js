import{_ as t,c as a,a6 as o,o as i}from"./chunks/framework.DMnHmf6x.js";const s="/documentation/img/bestpractice/flatgeobuf-layout.png",p=JSON.parse('{"title":"FlatGeobuf","description":"","frontmatter":{"order":5},"headers":[],"relativePath":"Community and Best Practices/Data and Workflow Best Practices/Data/flatgeobuff.md","filePath":"Community and Best Practices/Data and Workflow Best Practices/Data/flatgeobuff.md"}'),r={name:"Community and Best Practices/Data and Workflow Best Practices/Data/flatgeobuff.md"};function l(n,e,f,c,d,h){return i(),a("div",null,e[0]||(e[0]=[o('<h1 id="flatgeobuf" tabindex="-1">FlatGeobuf <a class="header-anchor" href="#flatgeobuf" aria-label="Permalink to &quot;FlatGeobuf&quot;">​</a></h1><p>FlatGeobuf is a modern, high-performance binary format for vector data (points, lines, and polygons). While traditional formats like GeoJSON or Shapefiles are common, they are often inefficient for cloud and web-based workflows, typically requiring a full file download to perform a spatial query. FlatGeobuf is specifically designed to solve this problem by enabling fast, partial access to large vector datasets over the network.</p><p><img src="'+s+'" alt="FlatGeobuf layout"></p><ul><li>MB: Magic bytes</li><li>H: Header (variable size flatbuffer),</li><li>I (optional): Static packed Hilbert R-tree index (static size custom buffer),</li><li>DATA: Features (variable size flatbuffers)</li></ul><h3 id="how-it-works" tabindex="-1">How it Works <a class="header-anchor" href="#how-it-works" aria-label="Permalink to &quot;How it Works&quot;">​</a></h3><p>The key feature of FlatGeobuf is a spatial index that is stored directly within the single file. This allows a client application to perform a highly efficient two-step read over the network:</p><ol><li>First, the client sends a small HTTP range request to fetch only the file header, which contains the spatial index.</li><li>The client uses this index to quickly determine which features are located within a specific geographic bounding box (e.g., the current map view).</li><li>Finally, it makes a second, targeted request to download <em>only the data for those specific features</em>, avoiding the need to transfer the entire file.</li></ol><p>This makes FlatGeobuf an ideal format for web mapping applications and any workflow that involves displaying or analyzing a subset of a large vector dataset. It is a simple, single-file format that is fully compatible with standard geospatial tools through the GDAL/OGR library, making it easy to use in Python, R, and other environments.</p><p>It is important to note that to enable this fast, random access to features, the FlatGeobuf format is uncompressed.</p><h2 id="when-to-use-flatgeobuf-in-earthcode" tabindex="-1">When to Use FlatGeobuf in EarthCODE <a class="header-anchor" href="#when-to-use-flatgeobuf-in-earthcode" aria-label="Permalink to &quot;When to Use FlatGeobuf in EarthCODE&quot;">​</a></h2><p>You should use FlatGeobuf when you have a <strong>large vector dataset</strong> and the primary use case involves users accessing a <strong>spatial subset</strong> of that data, especially in web-based applications. It is the recommended format for making large collections of points, lines, or polygons efficiently available for remote clients.</p><p><strong>For very small datasets (e.g., a few hundred features), the benefits of FlatGeobuf&#39;s spatial index are minimal, and a simple GeoJSON may be sufficient.</strong></p><p>Good candidates for FlatGeobuf include:</p><ul><li><strong>Interactive Web Maps:</strong> Datasets that need to be displayed on a map where users can pan and zoom. The client can dynamically fetch only the features visible in the current view, ensuring a fast and responsive experience.</li><li><strong>Spatial Querying:</strong> Any workflow where users or applications need to extract all features within a specific Area of Interest (AOI) without downloading the entire file.</li><li><strong>Large Point Collections:</strong> Datasets with many thousands or millions of points, such as global in-situ measurements or the output of a feature detection algorithm.</li></ul><h2 id="describing-flatgeobufs-with-stac-for-earthcode" tabindex="-1">Describing FlatGeoBufs with STAC For EarthCODE <a class="header-anchor" href="#describing-flatgeobufs-with-stac-for-earthcode" aria-label="Permalink to &quot;Describing FlatGeoBufs with STAC For EarthCODE&quot;">​</a></h2><p>A FlatGeobuf file is treated as a single asset within a STAC Item. The STAC Item provides the overall spatial and temporal metadata for the entire collection of features contained within the file.</p><p>The key requirements for describing a FlatGeobuf asset are:</p><ol><li><strong>Create a STAC Item:</strong> The Item&#39;s <code>bbox</code> and <code>datetime</code> properties should cover the full extent of all features within the FlatGeobuf file.</li><li><strong>Define the Asset:</strong> Within the Item&#39;s <code>assets</code> dictionary, create an entry for your file. <ul><li>The <code>href</code> must be the URL to your <code>.fgb</code> file.</li><li>The <code>type</code> (media type) must be set to <code>application/vnd.flatgeobuf</code>. This is essential for client applications to correctly identify the format.</li></ul></li></ol>',18)]))}const m=t(r,[["render",l]]);export{p as __pageData,m as default};
