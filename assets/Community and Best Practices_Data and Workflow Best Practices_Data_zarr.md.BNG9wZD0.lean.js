import{_ as s,c as i,a5 as e,o as t}from"./chunks/framework.Db4N_Fl1.js";const n="/documentation/img/bestpractice/zarr-data-variables-coordinates.png",r="/documentation/img/bestpractice/zarr-chunk-hierarchy.png",u=JSON.parse('{"title":"Zarr","description":"","frontmatter":{"order":3},"headers":[],"relativePath":"Community and Best Practices/Data and Workflow Best Practices/Data/zarr.md","filePath":"Community and Best Practices/Data and Workflow Best Practices/Data/zarr.md"}'),o={name:"Community and Best Practices/Data and Workflow Best Practices/Data/zarr.md"};function l(h,a,p,d,c,k){return t(),i("div",null,a[0]||(a[0]=[e('<h1 id="zarr" tabindex="-1">Zarr <a class="header-anchor" href="#zarr" aria-label="Permalink to &quot;Zarr&quot;">​</a></h1><h2 id="what-is-zarr" tabindex="-1">What is Zarr <a class="header-anchor" href="#what-is-zarr" aria-label="Permalink to &quot;What is Zarr&quot;">​</a></h2><p>Zarr is an open-source format designed for storing large, N-dimensional data cubes in the cloud. It is ideal for datasets that are too large to be handled efficiently as single, monolithic files, such as time-series of satellite imagery or outputs from climate and weather models.</p><p>Instead of a single file, a Zarr store is a collection of many small files or objects. The large N-dimensional array is broken down into smaller, blocks called <strong>chunks</strong>, and each chunk is stored as a separate, compressed object (or several <a href="https://zarr.readthedocs.io/en/stable/user-guide/arrays.html#user-guide-sharding" target="_blank" rel="noreferrer">chunks combined and stored as &quot;shards&quot;</a>). The entire structure of the dataset—including the dimensions, data types, and the location of every chunk—is described in small, JSON metadata files, and is typically consolidated into one metadata file (often named <code>.zmetadata</code>).</p><p><img src="'+n+'" alt="Zarr data variables and coordinates"></p><details class="details custom-block"><summary>What is a Data Cube</summary><p>A data cube is a multi-dimensional array used to organize complex data. While a standard 2D image has dimensions like <code>latitude</code> and <code>longitude</code>, a data cube extends this by &quot;stacking&quot; data along additional dimensions. For example, a data series taken over a year can be organized into a cube with a <code>time</code> dimension.</p><p>This structure can be extended with even more dimensions, such as spectral bands, vertical levels - creating an N-dimensional array. Organizing data this way is powerful because it allows you to easily select subsets or slice the data—for instance, extracting a complete time series for a single geographic point with a single command.</p><p>To learn more about working with data cubes in a cloud environment, we recommend the <a href="https://eo-college.org/courses/cubes-and-clouds/" target="_blank" rel="noreferrer">Cubes and Clouds MOOC</a>.</p></details><p>This design enables highly efficient data access. A client application first reads the single, lightweight metadata file to get a &quot;map&quot; of the entire dataset. It can then calculate which specific chunks are needed to satisfy a user&#39;s request (e.g., a spatial subset or a time slice) and fetch <em>only those chunks</em>, often in parallel. This approach reduces data transfer and I/O overhead, making it possible to perform scalable analysis on massive datasets with tools like Xarray.</p><p>To ensure interoperability for geospatial data, the <strong>GeoZarr</strong> specification provides conventions for storing coordinate reference systems and other critical metadata within a Zarr store.</p><details class="details custom-block"><summary>Best Practice GeoZarr</summary><p>A plain Zarr file is just a container for data grids. To fix this, you must add location information by following the GeoZarr rules. EarthCODE requires Zarr files to follow the GeoZarr standard.</p><ul><li><p><strong>1. Name Your Dimensions:</strong> For each data variable (like <code>temperature</code>), you must add a tag called <code>_ARRAY_DIMENSIONS</code>. This tag should be a list of your dimension names in the correct order, like <code>[&quot;time&quot;, &quot;y&quot;, &quot;x&quot;]</code>. This makes the structure of your data grid clear to any tool.</p></li><li><p><strong>2. Provide Coordinate Values:</strong> For each dimension you name (like <code>time</code>, <code>y</code>, <code>x</code>), you must also provide a list of its values. For example, the <code>time</code> dimension needs a list of all the timestamps. This tells software exactly where each row, column, and time slice is located.</p></li><li><p><strong>3. Define the Map Projection (CRS):</strong> You must include the map projection information (the Coordinate Reference System, or CRS). This tells mapping software how to place your data grid correctly on a world map.</p></li><li><p><strong>4. Include Overviews (Highly Recommended):</strong> If your data will be viewed on a map, it is strongly recommended that you save smaller, lower-resolution versions of your data inside the Zarr file. These &quot;overviews&quot; or &quot;pyramids&quot; are essential for fast zooming and panning in web viewers and GIS software.</p></li></ul></details><p>Read the <a href="https://zarr.readthedocs.io/en/stable/user-guide/" target="_blank" rel="noreferrer">Zarr User Guide</a> for more information about the Zarr format.</p><h2 id="organisation-of-a-zarr-file" tabindex="-1">Organisation of a Zarr file <a class="header-anchor" href="#organisation-of-a-zarr-file" aria-label="Permalink to &quot;Organisation of a Zarr file&quot;">​</a></h2><p><img src="'+r+`" alt="Zarr chunk hierarchy"></p><details class="details custom-block"><summary>Zarr Organisation</summary><ul><li><p><strong>Hierarchy:</strong> The folder-like structure of a Zarr store. It&#39;s a tree of &quot;groups&quot; (folders) and &quot;arrays&quot; (the actual data). A group can contain other groups or arrays, but an array is a final endpoint.</p></li><li><p><strong>Group:</strong> A container that acts like a folder within a Zarr store. It can hold multiple arrays and other groups, helping to organize a complex dataset.</p></li><li><p><strong>Array:</strong> The core data container. It&#39;s a multi-dimensional grid (e.g., a 2D image or 3D cube) where all data points have the same data type, like &#39;32-bit integer&#39;.</p></li><li><p><strong>Dimension:</strong> An axis of an array. A 2D image has two dimensions (height, width), while a data cube could have three or more (e.g., time, latitude, longitude).</p></li><li><p><strong>Chunk:</strong> To handle large datasets, the main array is broken into smaller, equally-sized blocks called chunks. These are the basic units of storage and are often compressed and stored as individual files.</p></li><li><p><strong>Grid:</strong> The regular, grid-like pattern formed by all the chunks that make up the complete array. All chunks in an array have the same shape and fit together perfectly.</p></li><li><p><strong>Element:</strong> A single data value within an array, like one pixel in an image or one temperature reading in a data cube. Each element is located by its coordinates along the dimensions.</p></li></ul></details><h2 id="describing-zarr-with-stac-for-earthcode" tabindex="-1">Describing Zarr with STAC For EarthCODE <a class="header-anchor" href="#describing-zarr-with-stac-for-earthcode" aria-label="Permalink to &quot;Describing Zarr with STAC For EarthCODE&quot;">​</a></h2><p>For EarthCODE, a single logical Zarr dataset, should be described by a single STAC Collection. This provides a simple access point for users while ensuring the data is discoverable.</p><p>The following practices are expected:</p><ol><li><p><strong>One Collection per Zarr Store:</strong> Each complete Zarr dataset should be represented by one STAC Collection. This collection should include a collection-level asset that links directly to the root of the Zarr store.</p></li><li><p><strong>Use the Data Cube Extension:</strong> To make the contents of your Zarr store searchable, you must use the <strong>STAC Data Cube Extension</strong>. This extension is used to list the scientific variables (e.g., <code>temperature</code>, <code>precipitation</code>) and dimensions contained within the Zarr store directly in the STAC Collection&#39;s metadata. This allows users to find your dataset by searching the EarthCODE catalog for the specific variables they need.</p></li><li><p><strong>Consolidate Zarr Metadata:</strong> For optimal performance in the cloud, the Zarr store itself <strong>must</strong> have consolidated metadata. This creates a single <code>.zmetadata</code> file, allowing client applications to understand the entire structure of the data cube with a single request, avoiding potentially thousands of individual reads.</p></li></ol><p>See an example of the <a href="https://opensciencedata.esa.int/external/eoresults.esa.int/stac/collections/YIPEEO-CROPYIELDS" target="_blank" rel="noreferrer">STAC metadata for Zarr.</a></p><p>This approach provides users have a simple access point to the entire data cube, while the key variables remain discoverable through the main EarthCODE catalog.</p><p>For a detailed, step-by-step guide on generating the required STAC metadata for a Zarr dataset, please follow the <a href="https://esa-earthcode.github.io/tutorials/prr-zarr/" target="_blank" rel="noreferrer">EarthCODE Zarr Tutorial</a>.</p><h2 id="using-zarr" tabindex="-1">Using Zarr <a class="header-anchor" href="#using-zarr" aria-label="Permalink to &quot;Using Zarr&quot;">​</a></h2><p>To access a Zarr dataset, first search the EarthCODE STAC catalog to find the relevant <strong>Collection</strong> on the Open Science catalog and retrieve the Zarr store&#39;s URL from the asset link and open it directly with a library like <strong>Xarray</strong>. This creates a <em>lazily-loaded</em> data cube by reading only the consolidated metadata upfront. Actual data is only streamed from the cloud when you perform a computation.</p><p>From that point, STAC&#39;s role in discovery is complete. All analysis—subsetting by time or space, filtering, and calculating—is done using Xarray&#39;s powerful functions directly on the data cube.</p><p>See an example of how to load and work with Zarr data on EarthCODE in the <a href="https://esa-earthcode.github.io/tutorials" target="_blank" rel="noreferrer">EarthCODE tutorial pages</a>.</p><h2 id="when-to-use-zarr-in-earthcode" tabindex="-1">When to Use Zarr in EarthCODE <a class="header-anchor" href="#when-to-use-zarr-in-earthcode" aria-label="Permalink to &quot;When to Use Zarr in EarthCODE&quot;">​</a></h2><p>You are encouraged to use Zarr when your dataset can be represented as a <strong>well-aligned, multi-dimensional data cube</strong>.</p><p>This approach is ideal for regularly gridded data where individual data granules share a common spatial grid, resolution, and can be easily stacked along dimensions like time. By consolidating these into a single Zarr store, you create an analysis-ready product.</p><p>Good candidates for Zarr include:</p><ul><li>Time series from climate models or reanalysis products.</li><li>Gridded, composite satellite data that has been processed to a standard grid (e.g. Level 3 or Level 4 data).</li></ul><p>Conversely, if your data consists of un-aligned, individual scenes with varying footprints or acquisition times (such as Level 1 or Level 2 satellite imagery), the recommended approach is to use Cloud-Optimized GeoTIFFs (COGs) cataloged with STAC.</p><details class="details custom-block"><summary>Zip+Zarr on the PRR</summary><p>Currently, Zarr stores in the EarthCODE PRR are archived as single <code>.zip</code> files.</p><p><strong>Please note that this is an interim solution.</strong></p><p>The following Python example demonstrates how to use <code>fsspec</code> and <code>xarray</code> to read a <code>.zarr.zip</code> archive directly from an HTTP URL.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fsspec</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xarray </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> open_datatree</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> zarr.storage </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ZipStore</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fsspec.implementations.http </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HTTPFileSystem</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HttpZipStore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ZipStore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> __init__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, path) -&gt; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__init__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;r&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> path</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> _load_zip_zarr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(url, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">**</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kwargs):</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    fs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HTTPFileSystem(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">asynchronous</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">False</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">block_size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    zipfile </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fs.open(url)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    store </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HttpZipStore(zipfile)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> open_datatree(store, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">engine</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;zarr&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">**</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kwargs)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">url </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;https://eoresults.esa.int/d/YIPEEO-CROPYIELDS/2016/01/01/yipeeo-cropyields-sentinel2-features/features2.zarr.zip&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ds </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _load_zip_zarr(url)</span></span></code></pre></div><p>Writing Zipp+Zarr</p><div class="language-py vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">zip_path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;my_dataset.zarr.zip&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">with</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> zarr.ZipStore(zip_path, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;w&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> store:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ds.to_zarr(store, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">consolidated</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">True</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div></details><h2 id="converting-to-zarr" tabindex="-1">Converting to Zarr <a class="header-anchor" href="#converting-to-zarr" aria-label="Permalink to &quot;Converting to Zarr&quot;">​</a></h2><p>You will typically encounter two main situations when converting existing data archives into a cloud-optimized Zarr store.</p><p>For detailed instructions, please refer to the data conversion tutorials on the EarthCODE tutorial pages.</p><h3 id="from-a-collection-of-geotiffs-cogs" tabindex="-1">From a Collection of GeoTIFFs/COGs <a class="header-anchor" href="#from-a-collection-of-geotiffs-cogs" aria-label="Permalink to &quot;From a Collection of GeoTIFFs/COGs&quot;">​</a></h3><p>When your goal is to stack a collection of 2D GeoTIFF files into a multi-dimensional data cube (e.g., adding a <code>time</code> dimension), the most flexible approach is to use Python libraries.</p><p>Using <strong>Xarray</strong> with the <strong>rioxarray</strong> engine allows you to open a series of individual GeoTIFFs and combine them into a single data cube, which can then be written to a Zarr store.</p><p>Alternatively, GDAL offers <a href="https://gdal.org/en/stable/drivers/raster/zarr.html" target="_blank" rel="noreferrer">gdal_translate</a> and a zarr engine for converting.</p><h3 id="from-netcdf" tabindex="-1">From NetCDF <a class="header-anchor" href="#from-netcdf" aria-label="Permalink to &quot;From NetCDF&quot;">​</a></h3><p>Converting from NetCDF to Zarr is easy using Python, specifically with the <strong>Xarray</strong> library. The workflow involves opening your NetCDF file(s) into an Xarray Dataset and then using the <code>.to_zarr()</code> method to write the output.</p><p>It is critical to define an appropriate chunking scheme for your data&#39;s dimensions and to create a consolidated metadata file for optimal cloud performance.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xarray </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xr</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Open one or more NetCDF files into a single Dataset</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ds </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> xr.open_mfdataset(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;path/to/source_files/*.nc&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Write to a Zarr store with consolidated metadata and custom chunking</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ds.to_zarr(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;output.zarr&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    consolidated</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">True</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    mode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;w&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Example encoding to specify chunks for a variable (time, y, x)</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    encoding</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;temperature&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;chunks&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">256</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">256</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)}}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><details class="details custom-block"><summary>Best Practice: Chunking and Consolidation</summary><p>Optimizing your Zarr store&#39;s internal layout is critical for performance in a cloud environment. Follow these three key practices when creating your data.</p><ul><li><p><strong>Choose the Right Chunk Size and Shape</strong> The goal of chunking is to balance overhead and usability. Chunks that are too small lead to many slow network requests, while chunks that are too large are inefficient for partial access.</p><ul><li><strong>Size:</strong> Aim for a target chunk size between <strong>50 MB and 200 MB</strong> after compression. This is generally the sweet spot for cloud object storage.</li><li><strong>Shape:</strong> Align the shape of your chunks with the most common analysis patterns. For time-series analysis (accessing one location over all time), make chunks large in the time dimension and small in the spatial dimensions. For creating maps (accessing a large area at one time), make chunks large in the spatial dimensions and small (size 1) in the time dimension.</li></ul></li><li><p><strong>Avoid Writing Empty Chunks</strong> An &quot;empty chunk&quot; is a chunk that contains only the fill value (e.g., <code>NaN</code>). Writing these chunks to storage is wasteful, creating unnecessary files and metadata. Configure your Zarr writing library to detect and skip writing these empty chunks. A Zarr reader will see a <code>null</code> entry for that chunk in the metadata and will correctly fill the area with the appropriate fill value without needing to make a network request.</p></li><li><p><strong>Consolidate Your Metadata</strong> By default, a Zarr store&#39;s metadata is scattered across many small JSON files. In a cloud environment, reading all of these files can require hundreds of slow network requests. You <strong>must consolidate</strong> your metadata into a single master index file (<code>.zmetadata</code>). This allows a client to understand the entire structure of your data cube—including the location of every single chunk—with just <strong>one initial request</strong>. When using Python&#39;s Xarray, this is as simple as setting <code>consolidated=True</code> in the <code>.to_zarr()</code> method.</p></li></ul></details>`,43)]))}const m=s(o,[["render",l]]);export{u as __pageData,m as default};
